基本概念


3.1语法（这本书是按ECMA-262第3版的中的定义来讲的，会给出第5版的变化说明。）
ECMAScript的语法大量借鉴了C及其他类C语言（如Java和Perl）的语法。

3.1.1区分大小写
ECMAScript中的一切（变量、函数名和操作符）都区分大小写。变量名test和变量名Test分别表示两个不同的变量。
函数名不能使用关键字，比如typeof，但是typeOf就行.

3.1.2标识符
标识符：变量、函数、属性的名字，或者函数的参数。
标识符可以是按照下列格式规则组合起来的一或多个字符：
·第一个字符必须是一个字母、下划线、或一个美元符号；
·其他字符可以是字母、下划线、美元符号或数字。
按惯例，标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个有意义的单词的首字母大写，（非强制）例如：
firstSecond、myCar、doSomethingImportant

3.1.3注释
单行注释：//
块级注释：
/*
 *...(这行与下一行前的的*，不是必须的，是为提高注释的可读性。）
 *...
 */
 
 3.1.4语句
 语句以一个分号（；）结尾，如果省略分号，则由解析器确定语句的结尾（不推荐）
 可以使用C风格的语法把多条语句组合到一个代码块中，用{}括起来。
 
 
 
 
 3.2关键字和保留字
 保留字虽然没有任何特定的用途，但是它们有可能将来被用作关键字，也不能作为标识符。
 具体的关键字和保留字暂不记录。
 使用关键字作为标识符，会导致"Identifier Expected"错误。
 
 
 
 
 3.3变量
 ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。
 换句话说，每个变量仅仅是一个用于保存值的占位符而已。
 定义变量时要使用var操作符，后跟变量名，例如：var message;
 像上面messag这样未经过初始化的变量，会保存一个特殊的值——undefined。
 
 可以直接初始化变量，例如：var message="hi";像这样初始化变量并不会把它标记为字符串类型，
 初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值得类型，例如：
 var message = "hi";
 message = 100; (有效，但不推荐。）
 
 如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。
 也就是函数被调用时，就会创建该变量并为其赋值，之后该变量就立即被销毁。
 不过如果省略var操作符，那么函数里得变量就会变成一个全局变量。（不推荐，因为不好维护。）
 
 可以使用一条语句定义多个变量，用逗号分隔开，例如：
 var message = "hi",
     found = false;
     age = 29;   (换行和缩进不是必要的，但是可以提高可读性。）
     
     
 
 3.4数据类型
 5种简单的数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。
 还有一种复杂数据类型：Object。Obeject本质上是由一组无序的名和值的对组成的。
 ECMAScript不支持任何创建自定义类型的机制，所有值都是上述六种类型之一。
 
 
 3.4.1typeof操作符
 该操作符用于检测给定变量的数据类型。
 该操作符的操作数可以是变量，也可以是数值字面量。
 typeof是一个操作符而不是函数。
 typeof null会返回"Object"，因为特殊值null被认为是一个空的对象引用。
 从技术角度讲， typeof可能会返回值"function"，函数在ECMAScript中是对象，不是一种数据类型。
 然而，函数有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。
 
 
 3.4.2 Undefined类型
 Undefined类型只有一个值，即特殊的undefined。
 var message；
 alert（message == undefined）；//true
 包含undefined值得变量与尚未定义的变量还是不一样的。
 尚未声明的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（使用delete也可以，但没有意义，严格模式下会出错。）
 （声明就是写出变量名，或写出var 变量名；初始化就是给变量名赋值。）
 
 
 
 3.4.3Null类型
Null类型是第二个只有一个值的数据类型，这个特殊的值是null。
从逻辑角度看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"Object"的原因。
如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，
只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，例如：
if (car != null){
   //对car对象执行某些操作
} 
实际上，undefined值是派生自null值得，因此ECMA-262规定对它们的相等性测试要返回ture：
alert（null == undefined）； //ture
如果在意保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。



3.4.4Boolean类型
该类型只有两个值：ture和false，它们并不一定分别等于1或0。
Ture和False不是Boolean值，注意大小写。
虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。
要将一个值转换为其对应的Boolean值，应调用转型函数Boolean（）。该函数的转换规则：
数据类型    转换为ture的值    转换为false的值
Boolean    true                 false
String     任何非空字符串         ""（空字符）
Number     任何非零数，包括无穷大  0和NaN
Object     任何对象              null
Undefined  n/a                  undefined
理解这些转换规则，对理解流控制，如if语句，的相应Boolean转换非常重要，例如：
var message = "Hello World";
if (message){
   alert（"Value is ture")
}


3.4.5Number类型
格式可以是十进制、八进制、十六进制。
八进制的第一位必须是0，如果字面值中的数值超出了范围(0-7)，那么前面的0将被忽略，后面的数被当作十进制数解析，例如：c
八进制在严格模式下是无效的。
十六进制字面值的前两位必须是0x,后面跟任何十六进制数字（0~9及A~F)。其中，字母A~F可以大写，也可以小写。
在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

浮点数值
所谓浮点数值，就是该数值中必须包含一个小数点。并且小数点后面必须至少有一位数字。
虽然小数点前面可以没有整数，但我们不推荐这种写法，例如 var floatNum= .1
由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。
显然，如果浮点数本身表示的就是一个整数(如1.0 、5. )，那么该值会被转换成整数。
对于极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值来表示。e可以大写。例如：
3.1e2表示3.12*10的2次方，1.1*e-3表示1.1乘以10的-3次方。
浮点数值的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数。例如：
0.1加上0.2的结果不是0.3，而是0.30000000000000004。
这个小小的舍入误差会导致无法测试特定的浮点数值。例如：
if （a + b == 0.3）{     //不要做这样的测试！
   alert（"You got 0.3."）
}
这个误差问题，是因为使用基于IEEE754数值的浮点计算的通病，其他使用相同数值格式的语言也存在这个问题。

数值范围
由于内存的限制，ECMAScript不能保存世界上所有的数值。
ECMAScript能够表示的最小数值保存在Number。MIN_VALUE中
如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的Infinity值。
具体来说，如果这个数值是负数，会被转换成-Infinity。
如果要确定一个数值是不是有穷的（在最大值和最小值之间），可以使用isFinite（）函数。在范围内则返回true。
访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正的Infinity的值。

NaN
NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。
这样可以避免抛出错误。例如，其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。
但在ECMAScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。
NaN有两个非同寻常的特点：
1、任何涉及NaN的操作都会返回NaN，这个特点在多布计算中可能会导致问题。
2、NaN与任何值都不相等，包括NaN本身。
针对这两个特点，ECMAScript定义了isNaN（）函数。这个函数接受一个参数，该参数可以是任何类型。
函数会帮我们确定这个参数是否“不是数值”。isNaN（）在接收到一个值之后，会尝试将这个值转换为数值。
某些不是数值的值会被直接转换为数值，例如字符串“10”或Boolean值。
而任何不能被转换为数值的值都会导致这个函数返回true，例如：
alert（isNaN（NaN））；    //ture
alert（isNaN（10））；     //false
alert（isNaN（“10”））；   //false
alert（isNaN（“blue”））； //true
alert（isNaN（true））；   //false


数值转换
有3个函数可以把非数值转换为数值：Number（）、parseInt（）和parseFloat（）。
Number（）可以用于任何数据类型，另外两个专门用于把字符串转换为数值。
Number（）的转换规则：
·如果是Boolean值，true和false将分别被转换为1和0。
·如果是数字值，只是简单的传入和返回。
·如果是null值，返回0。
·如果是undefined，返回NaN。
·如果是字符串，遵守下列规则：
  ·如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值。（“011”会变成11）
  ·如果字符串中包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（同样也会忽略前面的零）
  ·如果字符串中包含有效的十六进制格式，例如“0xf”，则将其转换为相同大小的十进制整数值。
  ·如果字符串是空的（不包含任何字符），则将其转换为0。
  ·如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
·如果是对象，则调用对象的valueOf（）方法，然后依照前面的规则转换返回的值。
 如果转换的结果是NaN，则调用对象的toString（）方法，然后再次依照前面的规则转换返回的字符串值。
由于Number（）函数再转换字符串时比较复杂且不够合理，因此在处理整数的时候更常用的是parseInt（）函数。
parseInt（）函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直到找到第一个非空格字符。
如果第一个字符不是数字字符或者负号，parseInt（）就会返回NaN。
也就是说，用parseInt（）转换空字符串会返回NaN（Number（）对空字符返回0）。
如果第一个字符是数字字符，parseInt（）会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。
例如：“1234blue"会被转换为1234，“22.5”会被转换为22。
如果第一个字符是数字字符，parseInt（）也能够识别出各种整数格式（十进制，八进制，十六进制数）。
例如：“070”会被转换为56（八进制的70就是56），“0xf”会被转换为15（十六进制的f就是15）。
不过ECMAScript3和5在parseInt（）解析八进制字面量的字符串时，有分歧，ECMAScript3如前所示，ECMAScript5则认为是0。
为了消除上面的这个困惑，可以为parseInt（）提供第二个参数：转换时使用的基数（即多少进制），建议指定基数，例如：
var num = parseInt（“0xAF",16)；//175
parseFloat（）不同于parseInt（）的两个地方：
1、字符串中第一个小数点时有效的，第二个无效，例如“22.34.5”将被转换成22.34。
2、parseFloat()会始终忽略前导的零，只解析十进制值，没有用第二个参数指定基数的用法。例如：“0xA”会被转换为0
不过，如果字符串包含的是一个可解析为整数的数，parseFloat（）会返回整数。parseFloathe（）可以识别出科学计数法，例如“2.1e2”会被转换为210。



3.4.6String类型




