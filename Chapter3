基本概念


3.1语法（这本书是按ECMA-262第3版的中的定义来讲的，会给出第5版的变化说明。）
ECMAScript的语法大量借鉴了C及其他类C语言（如Java和Perl）的语法。

3.1.1区分大小写
ECMAScript中的一切（变量、函数名和操作符）都区分大小写。变量名test和变量名Test分别表示两个不同的变量。
函数名不能使用关键字，比如typeof，但是typeOf就行.

3.1.2标识符
标识符：变量、函数、属性的名字，或者函数的参数。
标识符可以是按照下列格式规则组合起来的一或多个字符：
·第一个字符必须是一个字母、下划线、或一个美元符号；
·其他字符可以是字母、下划线、美元符号或数字。
按惯例，标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个有意义的单词的首字母大写，（非强制）例如：
firstSecond、myCar、doSomethingImportant

3.1.3注释
单行注释：//
块级注释：
/*
 *...(这行与下一行前的的*，不是必须的，是为提高注释的可读性。）
 *...
 */
 
 3.1.4语句
 语句以一个分号（；）结尾，如果省略分号，则由解析器确定语句的结尾（不推荐）
 可以使用C风格的语法把多条语句组合到一个代码块中，用{}括起来。
 
 
 
 
 3.2关键字和保留字
 保留字虽然没有任何特定的用途，但是它们有可能将来被用作关键字，也不能作为标识符。
 具体的关键字和保留字暂不记录。
 使用关键字作为标识符，会导致"Identifier Expected"错误。
 
 
 
 
 3.3变量
 ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。
 换句话说，每个变量仅仅是一个用于保存值的占位符而已。
 定义变量时要使用var操作符，后跟变量名，例如：var message;
 像上面messag这样未经过初始化的变量，会保存一个特殊的值——undefined。
 
 可以直接初始化变量，例如：var message="hi";像这样初始化变量并不会把它标记为字符串类型，
 初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值得类型，例如：
 var message = "hi";
 message = 100; (有效，但不推荐。）
 
 如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。
 也就是函数被调用时，就会创建该变量并为其赋值，之后该变量就立即被销毁。
 不过如果省略var操作符，那么函数里得变量就会变成一个全局变量。（不推荐，因为不好维护。）
 
 可以使用一条语句定义多个变量，用逗号分隔开，例如：
 var message = "hi",
     found = false;
     age = 29;   (换行和缩进不是必要的，但是可以提高可读性。）
     
     
 
 3.4数据类型
 5种简单的数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。
 还有一种复杂数据类型：Object。Obeject本质上是由一组无序的名和值的对组成的。
 ECMAScript不支持任何创建自定义类型的机制，所有值都是上述六种类型之一。
 
 
 3.4.1typeof操作符
 该操作符用于检测给定变量的数据类型。
 该操作符的操作数可以是变量，也可以是数值字面量。
 typeof是一个操作符而不是函数。
 typeof null会返回"Object"，因为特殊值null被认为是一个空的对象引用。
 从技术角度讲， typeof可能会返回值"function"，函数在ECMAScript中是对象，不是一种数据类型。
 然而，函数有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。
 
 
 3.4.2 Undefined类型
 Undefined类型只有一个值，即特殊的undefined。
 var message；
 alert（message == undefined）；//true
 包含undefined值得变量与尚未定义的变量还是不一样的。
 尚未声明的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（使用delete也可以，但没有意义，严格模式下会出错。）
 （声明就是写出变量名，或写出var 变量名；初始化就是给变量名赋值。）
 
 
 
 3.4.3Null类型
Null类型是第二个只有一个值的数据类型，这个特殊的值是null。
从逻辑角度看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"Object"的原因。
如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，
只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，例如：
if (car != null){
   //对car对象执行某些操作
} 
实际上，undefined值是派生自null值得，因此ECMA-262规定对它们的相等性测试要返回ture：
alert（null == undefined）； //ture
如果在意保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。



3.4.4Boolean类型
该类型只有两个值：ture和false，它们并不一定分别等于1或0。
Ture和False不是Boolean值，注意大小写。
虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。
要将一个值转换为其对应的Boolean值，应调用转型函数Boolean（）。该函数的转换规则：
数据类型    转换为ture的值    转换为false的值
Boolean    true                 false
String     任何非空字符串         ""（空字符）
Number     任何非零数，包括无穷大  0和NaN
Object     任何对象              null
Undefined  n/a                  undefined
理解这些转换规则，对理解流控制，如if语句，的相应Boolean转换非常重要，例如：
var message = "Hello World";
if (message){
   alert（"Value is ture")
}


3.4.5Number类型
格式可以是十进制、八进制、十六进制。
八进制的第一位必须是0，如果字面值中的数值超出了范围(0-7)，那么前面的0将被忽略，后面的数被当作十进制数解析，例如：c
八进制在严格模式下是无效的。
十六进制字面值的前两位必须是0x,后面跟任何十六进制数字（0~9及A~F)。其中，字母A~F可以大写，也可以小写。
在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

浮点数值
所谓浮点数值，就是该数值中必须包含一个小数点。并且小数点后面必须至少有一位数字。
虽然小数点前面可以没有整数，但我们不推荐这种写法，例如 var floatNum= .1
由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。
显然，如果浮点数本身表示的就是一个整数(如1.0 、5. )，那么该值会被转换成整数。
对于极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值来表示。e可以大写。例如：
3.1e2表示3.12*10的2次方，1.1*e-3表示1.1乘以10的-3次方。
浮点数值的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数。例如：
0.1加上0.2的结果不是0.3，而是0.30000000000000004。
这个小小的舍入误差会导致无法测试特定的浮点数值。例如：
if （a + b == 0.3）{     //不要做这样的测试！
   alert（"You got 0.3."）
}
这个误差问题，是因为使用基于IEEE754数值的浮点计算的通病，其他使用相同数值格式的语言也存在这个问题。

数值范围
由于内存的限制，ECMAScript不能保存世界上所有的数值。
ECMAScript能够表示的最小数值保存在Number。MIN_VALUE中
如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的Infinity值。
具体来说，如果这个数值是负数，会被转换成-Infinity。
如果要确定一个数值是不是有穷的（在最大值和最小值之间），可以使用isFinite（）函数。在范围内则返回true。
访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正的Infinity的值。

NaN
NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。
这样可以避免抛出错误。例如，其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。
但在ECMAScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。
NaN有两个非同寻常的特点：
1、任何涉及NaN的操作都会返回NaN，这个特点在多布计算中可能会导致问题。
2、NaN与任何值都不相等，包括NaN本身。
针对这两个特点，ECMAScript定义了isNaN（）函数。这个函数接受一个参数，该参数可以是任何类型。
函数会帮我们确定这个参数是否“不是数值”。isNaN（）在接收到一个值之后，会尝试将这个值转换为数值。
某些不是数值的值会被直接转换为数值，例如字符串“10”或Boolean值。
而任何不能被转换为数值的值都会导致这个函数返回true，例如：
alert（isNaN（NaN））；    //ture
alert（isNaN（10））；     //false
alert（isNaN（“10”））；   //false
alert（isNaN（“blue”））； //true
alert（isNaN（true））；   //false


数值转换
有3个函数可以把非数值转换为数值：Number（）、parseInt（）和parseFloat（）。
Number（）可以用于任何数据类型，另外两个专门用于把字符串转换为数值。
Number（）的转换规则：
·如果是Boolean值，true和false将分别被转换为1和0。
·如果是数字值，只是简单的传入和返回。
·如果是null值，返回0。
·如果是undefined，返回NaN。
·如果是字符串，遵守下列规则：
  ·如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值。（“011”会变成11）
  ·如果字符串中包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（同样也会忽略前面的零）
  ·如果字符串中包含有效的十六进制格式，例如“0xf”，则将其转换为相同大小的十进制整数值。
  ·如果字符串是空的（不包含任何字符），则将其转换为0。
  ·如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
·如果是对象，则调用对象的valueOf（）方法，然后依照前面的规则转换返回的值。
 如果转换的结果是NaN，则调用对象的toString（）方法，然后再次依照前面的规则转换返回的字符串值。
由于Number（）函数再转换字符串时比较复杂且不够合理，因此在处理整数的时候更常用的是parseInt（）函数。
parseInt（）函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直到找到第一个非空格字符。
如果第一个字符不是数字字符或者负号，parseInt（）就会返回NaN。
也就是说，用parseInt（）转换空字符串会返回NaN（Number（）对空字符返回0）。
如果第一个字符是数字字符，parseInt（）会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。
例如：“1234blue"会被转换为1234，“22.5”会被转换为22。
如果第一个字符是数字字符，parseInt（）也能够识别出各种整数格式（十进制，八进制，十六进制数）。
例如：“070”会被转换为56（八进制的70就是56），“0xf”会被转换为15（十六进制的f就是15）。
不过ECMAScript3和5在parseInt（）解析八进制字面量的字符串时，有分歧，ECMAScript3如前所示，ECMAScript5则认为是0。
为了消除上面的这个困惑，可以为parseInt（）提供第二个参数：转换时使用的基数（即多少进制），建议指定基数，例如：
var num = parseInt（“0xAF",16)；//175
parseFloat（）不同于parseInt（）的两个地方：
1、字符串中第一个小数点时有效的，第二个无效，例如“22.34.5”将被转换成22.34。
2、parseFloat()会始终忽略前导的零，只解析十进制值，没有用第二个参数指定基数的用法。例如：“0xA”会被转换为0
不过，如果字符串包含的是一个可解析为整数的数，parseFloat（）会返回整数。parseFloathe（）可以识别出科学计数法，例如“2.1e2”会被转换为210。



3.4.6String类型
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。
字符串可以由两个双引号或两个单引号表示。
字符字面量
String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或具有其他用途的字符：
字面量     含义
\n        换行
\t        制表
\b        空格
\r        回车
\f        进纸
\\        斜杠
\'        单引号，例如'He said, \'hey.\''
\"        双引号
\xnn      以十六进制代码nn表示的一个字符（其中n为0~F）。例如，\x41表示"A"
\unnnn    以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F）。例如,\u03a3表示希腊字符∑
上面这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析。
任何字符串的长度都可以通过访问其length属性取得。
这个属性返回的字符数包括16位字符的数目。如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。

字符串的特点
ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。
要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如：
var lang = “Java”；
lang = lang + “Script”
上面第二部的过程，在后台发生：1、创建一个能容纳10个字符的新字符串，然后填充“Java”和“Script”
                           2、销毁原来的字符串“Java”和字符串“Script”，因为这两个字符串已经没用了。

转换为字符串
把一个值转换为字符串，两种方式：
1、使用几乎每个值都有的toString（）方法。例如：
var age = 11；
var ageAsString = age.toString（）； //字符串“11”
var found = true ；
var foundAsString = found.toString();  //字符串“true”
null和undefined值没有这个方法。
toString（）方法可以指定一个参数，就是输出字符串里的数值的基数（多少进制），默认十进制。
在不知道要转换的值是不是null或undefined的情况下，还可以使用String()。规则：
·如果该值有toString方法，则调用该方法（没有参数）并返回相应的结果。
·如果值是null，则返回“null”。
·如果值是undefined，则返回“undefined”
*要把某个值转换为字符串，可以使用加号操作符把它与一个字符串""加在一起。



3.4.7Object类型
ECMAScript中的对象其实就是一组数据和功能的集合。
对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。
而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：
var o = new Object（）；//如果没有参数，可以忽略括号，但不推荐。
Object类型是所有它的实例的基础，换句话说，Object类型具有的任何属性和方法也同样存在于更具体地对象中。
Object的每个实例都具有下列属性和方法：
·Constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object（）。
·hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中是否存在。
 其中，作为参数的属性名（propertyName）必须以字符串形式指定（o.hasOwnproperty("name"))。
·isPrototypeOf（object）：用于检查传入的对象是否是另一个对象的原型。
·propertyIsEnumerable（propertyName）：用于检查给定的属性是否能够使用for-in语句来枚举。作为参数的属性名（propertyName）必须以字符串形式指定。
·toLocalString（）：返回对象的字符串表示，该字符串与执行环境的地区对应。
·toString（）；返回对象的字符串表示。
·valueOf（）：返回对象的字符串、数值或布尔值表示。通常与toString（）方法的返回值相同。
第五章和第六章会详细介绍Object与其他对象的关系。
*BOM和DOM中的对象，属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此
 宿主对象可能会也可能不会继承Object。
 
 
 
 
 3.5操作符
 ECMA-262描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。
 ECMAScript操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值、甚至对象。
 不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf（）和（或）toString（）方法，以便取得可以操作的值。
 
 3.5.1一元操作符
 只能操作一个值的操作符叫做一元操作符。一元操作符是ECMAScript中最简单的操作符。
 1.递增和递减操作符
 递增和递减操作符
 递增和递减操作符直接借鉴自C，而且各有两个版本：前置型和后置型（++和--在变量前或变量后）。
 前置递增和递减操作符、后置递增和递减操作符对任何值都适用。规则：（暂不记录，在第38页）
 2.一元加和减操作符（+和-）
 同样可以对非数值应用。
 
 3.5.2位操作符
 位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。
 ECMAScript中所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。
 而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。（可能是将64位拆成前后两个32位来分别处理。）
 对于有符号的整数，32位中的前31位（数的第一位在最右边）用于表示整数的值。第32位用于表示数值的符号：0表示正数，1表示负数。
 这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。
 其中，正数以纯二进制格式存储，31位中的每一位都表示2的幂。第一位（叫做位0）表示2的零次方，第二位表示2的一次方，以此类推。
 没有用到的位以0填充，即忽略不计。
 例如，数值18的二进制表示是00000000000000000000000000010010，或更简洁的10010（这是5个有效位，决定了实际的值。）
负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列3个步骤：
1、求这个数值绝对值的二进制码。
2、求二进制反码，即将0替换为1，将1替换为0。
3、得到的二进制反码加1。
值得注意的是，在处理有符号整数时，是不能访问位31的。
ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。
var num = -18; 
alert(num.toString(2));    // "-10010"
默认情况下，ECMAScript中的所有整数都是有符号整数。不过，当然也存在无符号整数。
对于无符号整数来说，第32位不再表示符号，因为无符号整数只能是正数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示数值。
在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过 程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的 结果转换回64位数值。这样，表面上看起来就好像是在操作32位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也 导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。 

1. 按位非（NOT）
按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数 值的反码。按位非是ECMAScript操作符中少数几个与二进制计算有关 的操作符之一。下面看一个例子：
var num1 = 25;                  // 二进制00000000000000000000000000011001 
var num2 = ~num1;               // 二进制11111111111111111111111111100110 
alert(num2);                    // -26
这里，对25执行按位非操作，结果得到了-26。这也验证了按位非操作 的本质：操作数的负值减1。
因此，下面的代码也能得到相同的结果：
var num1 = 25; 
var num2 = -num1 - 1; 
alert(num2);            // "-26"
虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底 层执行操作，因此速度更快。

2. 按位与（AND） 
按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质 上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规 则，对相同位置上的两个数执行AND操作：
第一个数值的位 第二个数值的位  结果 
1             1             1 
1             0             0 
0             1             0 
0             0             0
简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一 位是0，结果都是0。 
下面看一个对25和3执行按位与操作的例子：
var result = 25 & 3; 
alert(result);     //1
可见，对25和3执行按位与操作的结果是1。为什么呢？请看其底层操作：
25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3  =  0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001

3. 按位或（OR） 
按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或 操作遵循下面这个真值表。
第一个数值的位 第二个数值的位  结果 
1             1             1 
1             0             1 
0             1             1 
0             0             0
由此可见，按位或操作在有一个位是1的情况下就返回1，而只有在两个 位都是0的情况下才返回0。 

4. 按位异或（XOR） 
按位异或操作符由一个插入符号（^）表示，也有两个操作数。以下是 按位异或的真值表。
第一个数值的位 第二个数值的位  结果 
1             1             0
1             0             1 
0             1             1 
0             0             0
按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有 一个1时才返回1，如果对应的两位都是1或都是0，则返回0。 

5. 左移
左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向 左移动指定的位数。例如，如果将数值2（二进制码为10）向左移动5 位，结果就是64（二进制码为1000000），代码如下所示：
var oldValue = 2;                       // 等于二进制的10
var newValue = oldValue << 5;           // 等于二进制的1000000，十进
注意，在向左移位后，原数值的右侧多出了5个空位。左移操作会以0来 填充这些空位，以便得到的结果是一个完整的32位二进制数。
注意，左移不会影响操作数的符号位。换句话说，如果将-2向左移动5 位，结果将是-64，而非64。 

6. 有符号的右移
有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向 右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2
同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现 在原数值的左侧、符号位的右侧。而此时ECMAScript会用符号位的值来填充所有空位(如果符号位是1就用1填充，是0就用0填充），以便得到一个完整的值。

7. 无符号右移
无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所 有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将64无符号右移5位，结果 仍然还是2。
但是对负数来说，情况就不一样了。
首先，无符号右移是以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数 的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。
其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。
而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：
var oldValue = -64;                     // 等于二进制的11111111111111111111111111000000 
var newValue = oldValue >>> 5;          // 等于十进制的134217726
这里，当对-64执行无符号右移5位的操作后，得到的结果是 134217726。之所以结果如此之大，是因为-64的二进制码为 11111111111111111111111111000000，而且无符号右移操作会把这个二进制码当成正数的二进制码，换算成十进制就是4294967232。如果把这个值右移5位，结果就变成了00000111111111111111111111111110，即 十进制的134217726。 




3.5.3　布尔操作符
在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么诸如if...else和循环之类的语句就不会有用武之地了。布尔操作符一共有3个：非（NOT）、与（AND）和或 （OR）。
1. 逻辑非（NOT)
逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript中的任 何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。 逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求 反。也就是说，逻辑非操作符遵循下列规则：
·如果操作数是一个对象，返回false； 
·如果操作数是一个空字符串，返回true； 
·如果操作数是一个非空字符串，返回false； 
·如果操作数是数值0，返回true； 
·如果操作数是任意非0数值（包括Infinity），返回false； 
·如果操作数是null，返回true； 
·如果操作数是NaN，返回true； 
·如果操作数是undefined，返回true。
逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使 用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。其 中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二 个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔 值。当然，最终结果与对这个值使用Boolean()函数相同。（就是连续两个！！就相当于Boolean（））
2. 逻辑与(AND)
逻辑与操作符由两个和号（&&）表示，有两个操作数。（真值表不打了，跟数学里的一样。）
逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：
·如果第一个操作数是对象，则返回第二个操作数；
·如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；
·如果两个操作数都是对象，则返回第二个操作数（这时，也就是第二个对象）； 
·如果有一个操作数是null，则返回null； 
·如果有一个操作数是NaN，则返回NaN； 
·如果有一个操作数是undefined，则返回undefined。
逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就 不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数 是false，则无论第二个操作数是什么值，结果都不再可能是true了。 来看下面的例子：
var found = true;
var result = (found && someUndefinedVariable);    // 这里会发生错误 
alert(result);    // 这一行不会执行
在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 someUndefinedVariable没有声明。由于变量found的值是true，所 以逻辑与操作符会继续对变量someUndefinedVariable求值。 但someUndefinedVariable尚未定义，因此就会导致错误。
这说明不能在逻辑与操作中使用未定义的值。将found的值设置为false，就不会发生错误了。
在使用逻辑与操作 符时要始终铭记它是一个短路操作符。
3. 逻辑或
逻辑或操作符由两个竖线符号（||）表示，有两个操作数。（真值表和数学里一样）
与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返 回布尔值；此时，它遵循下列规则：
·如果第一个操作数是对象，则返回第一个操作数；
·如果第一个操作数的求值结果为false，则返回第二个操作数；
·如果两个操作数都是对象，则返回第一个操作数；
·如果两个操作数都是null，则返回null； 
·如果两个操作数都是NaN，则返回NaN； 
·如果两个操作数都是undefined，则返回undefined。
与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果 第一个操作数的求值结果为true，就不会对第二个操作数求值了。
我们可以利用逻辑或的这一行为来避免为变量赋null或undefined值。 
例如：
var myObject = preferredObject || backupObject; （别看到有object，就当成是对象了，下面说了是变量。）
在这个例子中，变量myObject将被赋予等号后面两个值中的一个。变量preferredObject中包含优先赋给变量myObject的值，变量 backupObject负责在preferredObject中不包含有效值的情况下提供 后备值。如果preferredObject的值不是null，那么它的值将被赋给
myObject；如果是null，则将backupObject的值赋给myObject。 ECMAScript程序的赋值语句经常会使用这种模式，本书也将采用这种模式。




3.5.4　乘性操作符
ECMAScript定义了3个乘性操作符：乘法、除法和求模。这些操作符与 Java、C或者Perl中的相应操作符用途类似，只不过在操作数为非数值的 情况下会执行自动的类型转换。如果参与乘法计算的某个操作数不是数 值，后台会先使用Number()转型函数将其转换为数值。也就是说，空 字符串将被当作0，布尔值true将被当作1。
1. 乘法
乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。其语法 类似于C，如下面的例子所示：
var result = 34 * 56;
在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：




