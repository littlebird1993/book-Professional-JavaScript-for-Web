基本概念


3.1语法（这本书是按ECMA-262第3版的中的定义来讲的，会给出第5版的变化说明。）
ECMAScript的语法大量借鉴了C及其他类C语言（如Java和Perl）的语法。

3.1.1区分大小写
ECMAScript中的一切（变量、函数名和操作符）都区分大小写。变量名test和变量名Test分别表示两个不同的变量。
函数名不能使用关键字，比如typeof，但是typeOf就行.

3.1.2标识符
标识符：变量、函数、属性的名字，或者函数的参数。
标识符可以是按照下列格式规则组合起来的一或多个字符：
·第一个字符必须是一个字母、下划线、或一个美元符号；
·其他字符可以是字母、下划线、美元符号或数字。
按惯例，标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个有意义的单词的首字母大写，（非强制）例如：
firstSecond、myCar、doSomethingImportant

3.1.3注释
单行注释：//
块级注释：
/*
 *...(这行与下一行前的的*，不是必须的，是为提高注释的可读性。）
 *...
 */
 
 3.1.4语句
 语句以一个分号（；）结尾，如果省略分号，则由解析器确定语句的结尾（不推荐）
 可以使用C风格的语法把多条语句组合到一个代码块中，用{}括起来。
 
 
 
 
 3.2关键字和保留字
 保留字虽然没有任何特定的用途，但是它们有可能将来被用作关键字，也不能作为标识符。
 具体的关键字和保留字暂不记录。
 使用关键字作为标识符，会导致"Identifier Expected"错误。
 
 
 
 
 3.3变量
 ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。
 换句话说，每个变量仅仅是一个用于保存值的占位符而已。
 定义变量时要使用var操作符，后跟变量名，例如：var message;
 像上面messag这样未经过初始化的变量，会保存一个特殊的值——undefined。
 
 可以直接初始化变量，例如：var message="hi";像这样初始化变量并不会把它标记为字符串类型，
 初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值得类型，例如：
 var message = "hi";
 message = 100; (有效，但不推荐。）
 
 如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。
 也就是函数被调用时，就会创建该变量并为其赋值，之后该变量就立即被销毁。
 不过如果省略var操作符，那么函数里得变量就会变成一个全局变量。（不推荐，因为不好维护。）
 
 可以使用一条语句定义多个变量，用逗号分隔开，例如：
 var message = "hi",
     found = false;
     age = 29;   (换行和缩进不是必要的，但是可以提高可读性。）
     
     
 
 3.4数据类型
 5种简单的数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。
 还有一种复杂数据类型：Object。Obeject本质上是由一组无序的名和值的对组成的。
 ECMAScript不支持任何创建自定义类型的机制，所有值都是上述六种类型之一。
 
 
 3.4.1typeof操作符
 该操作符用于检测给定变量的数据类型。
 该操作符的操作数可以是变量，也可以是数值字面量。
 typeof是一个操作符而不是函数。
 typeof null会返回"Object"，因为特殊值null被认为是一个空的对象引用。
 从技术角度讲， typeof可能会返回值"function"，函数在ECMAScript中是对象，不是一种数据类型。
 然而，函数有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。
 
 
 3.4.2 Undefined类型
 Undefined类型只有一个值，即特殊的undefined。
 var message；
 alert（message == undefined）；//true
 包含undefined值得变量与尚未定义的变量还是不一样的。
 尚未声明的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（使用delete也可以，但没有意义，严格模式下会出错。）
 （声明就是写出变量名，或写出var 变量名；初始化就是给变量名赋值。）
 
 
 
 3.4.3Null类型
Null类型是第二个只有一个值的数据类型，这个特殊的值是null。
从逻辑角度看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"Object"的原因。
如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，
只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，例如：
if (car != null){
   //对car对象执行某些操作
} 
实际上，undefined值是派生自null值得，因此ECMA-262规定对它们的相等性测试要返回ture：
alert（null == undefined）； //ture
如果在意保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。



3.4.4Boolean类型
该类型只有两个值：ture和false，它们并不一定分别等于1或0。
Ture和False不是Boolean值，注意大小写。
虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。
要将一个值转换为其对应的Boolean值，应调用转型函数Boolean（）。该函数的转换规则：
数据类型    转换为ture的值    转换为false的值
Boolean    true                 false
String     任何非空字符串         ""（空字符）
Number     任何非零数，包括无穷大  0和NaN
Object     任何对象              null
Undefined  n/a                  undefined
理解这些转换规则，对理解流控制，如if语句，的相应Boolean转换非常重要，例如：
var message = "Hello World";
if (message){
   alert（"Value is ture")
}


3.4.5Number类型
格式可以是十进制、八进制、十六进制。
八进制的第一位必须是0，如果字面值中的数值超出了范围(0-7)，那么前面的0将被忽略，后面的数被当作十进制数解析，例如：c
八进制在严格模式下是无效的。
十六进制字面值的前两位必须是0x,后面跟任何十六进制数字（0~9及A~F)。其中，字母A~F可以大写，也可以小写。
在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

浮点数值
所谓浮点数值，就是该数值中必须包含一个小数点。并且小数点后面必须至少有一位数字。
虽然小数点前面可以没有整数，但我们不推荐这种写法，例如 var floatNum= .1
由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。
显然，如果浮点数本身表示的就是一个整数(如1.0 、5. )，那么该值会被转换成整数。
对于极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值来表示。e可以大写。例如：
3.1e2表示3.12*10的2次方，1.1*e-3表示1.1乘以10的-3次方。
浮点数值的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数。例如：
0.1加上0.2的结果不是0.3，而是0.30000000000000004。
这个小小的舍入误差会导致无法测试特定的浮点数值。例如：
if （a + b == 0.3）{     //不要做这样的测试！
   alert（"You got 0.3."）
}
这个误差问题，是因为使用基于IEEE754数值的浮点计算的通病，其他使用相同数值格式的语言也存在这个问题。

数值范围
由于内存的限制，ECMAScript不能保存世界上所有的数值。
ECMAScript能够表示的最小数值保存在Number。MIN_VALUE中
如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的Infinity值。
具体来说，如果这个数值是负数，会被转换成-Infinity。
如果要确定一个数值是不是有穷的（在最大值和最小值之间），可以使用isFinite（）函数。在范围内则返回true。
访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正的Infinity的值。

NaN
NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。
这样可以避免抛出错误。例如，其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。
但在ECMAScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。
NaN有两个非同寻常的特点：
1、任何涉及NaN的操作都会返回NaN，这个特点在多布计算中可能会导致问题。
2、NaN与任何值都不相等，包括NaN本身。
针对这两个特点，ECMAScript定义了isNaN（）函数。这个函数接受一个参数，该参数可以是任何类型。
函数会帮我们确定这个参数是否“不是数值”。isNaN（）在接收到一个值之后，会尝试将这个值转换为数值。
某些不是数值的值会被直接转换为数值，例如字符串“10”或Boolean值。
而任何不能被转换为数值的值都会导致这个函数返回true，例如：
alert（isNaN（NaN））；    //ture
alert（isNaN（10））；     //false
alert（isNaN（“10”））；   //false
alert（isNaN（“blue”））； //true
alert（isNaN（true））；   //false


数值转换
有3个函数可以把非数值转换为数值：Number（）、parseInt（）和parseFloat（）。
Number（）可以用于任何数据类型，另外两个专门用于把字符串转换为数值。
Number（）的转换规则：
·如果是Boolean值，true和false将分别被转换为1和0。
·如果是数字值，只是简单的传入和返回。
·如果是null值，返回0。
·如果是undefined，返回NaN。
·如果是字符串，遵守下列规则：
  ·如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值。（“011”会变成11）
  ·如果字符串中包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（同样也会忽略前面的零）
  ·如果字符串中包含有效的十六进制格式，例如“0xf”，则将其转换为相同大小的十进制整数值。
  ·如果字符串是空的（不包含任何字符），则将其转换为0。
  ·如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
·如果是对象，则调用对象的valueOf（）方法，然后依照前面的规则转换返回的值。
 如果转换的结果是NaN，则调用对象的toString（）方法，然后再次依照前面的规则转换返回的字符串值。
由于Number（）函数再转换字符串时比较复杂且不够合理，因此在处理整数的时候更常用的是parseInt（）函数。
parseInt（）函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直到找到第一个非空格字符。
如果第一个字符不是数字字符或者负号，parseInt（）就会返回NaN。
也就是说，用parseInt（）转换空字符串会返回NaN（Number（）对空字符返回0）。
如果第一个字符是数字字符，parseInt（）会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。
例如：“1234blue"会被转换为1234，“22.5”会被转换为22。
如果第一个字符是数字字符，parseInt（）也能够识别出各种整数格式（十进制，八进制，十六进制数）。
例如：“070”会被转换为56（八进制的70就是56），“0xf”会被转换为15（十六进制的f就是15）。
不过ECMAScript3和5在parseInt（）解析八进制字面量的字符串时，有分歧，ECMAScript3如前所示，ECMAScript5则认为是0。
为了消除上面的这个困惑，可以为parseInt（）提供第二个参数：转换时使用的基数（即多少进制），建议指定基数，例如：
var num = parseInt（“0xAF",16)；//175
parseFloat（）不同于parseInt（）的两个地方：
1、字符串中第一个小数点时有效的，第二个无效，例如“22.34.5”将被转换成22.34。
2、parseFloat()会始终忽略前导的零，只解析十进制值，没有用第二个参数指定基数的用法。例如：“0xA”会被转换为0
不过，如果字符串包含的是一个可解析为整数的数，parseFloat（）会返回整数。parseFloathe（）可以识别出科学计数法，例如“2.1e2”会被转换为210。



3.4.6String类型
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。
字符串可以由两个双引号或两个单引号表示。
字符字面量
String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或具有其他用途的字符：
字面量     含义
\n        换行
\t        制表
\b        空格
\r        回车
\f        进纸
\\        斜杠
\'        单引号，例如'He said, \'hey.\''
\"        双引号
\xnn      以十六进制代码nn表示的一个字符（其中n为0~F）。例如，\x41表示"A"
\unnnn    以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F）。例如,\u03a3表示希腊字符∑
上面这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析。
任何字符串的长度都可以通过访问其length属性取得。
这个属性返回的字符数包括16位字符的数目。如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。

字符串的特点
ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。
要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如：
var lang = “Java”；
lang = lang + “Script”
上面第二部的过程，在后台发生：1、创建一个能容纳10个字符的新字符串，然后填充“Java”和“Script”
                           2、销毁原来的字符串“Java”和字符串“Script”，因为这两个字符串已经没用了。

转换为字符串
把一个值转换为字符串，两种方式：
1、使用几乎每个值都有的toString（）方法。例如：
var age = 11；
var ageAsString = age.toString（）； //字符串“11”
var found = true ；
var foundAsString = found.toString();  //字符串“true”
null和undefined值没有这个方法。
toString（）方法可以指定一个参数，就是输出字符串里的数值的基数（多少进制），默认十进制。
在不知道要转换的值是不是null或undefined的情况下，还可以使用String()。规则：
·如果该值有toString方法，则调用该方法（没有参数）并返回相应的结果。
·如果值是null，则返回“null”。
·如果值是undefined，则返回“undefined”
*要把某个值转换为字符串，可以使用加号操作符把它与一个字符串""加在一起。



3.4.7Object类型
ECMAScript中的对象其实就是一组数据和功能的集合。
对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。
而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：
var o = new Object（）；//如果没有参数，可以忽略括号，但不推荐。
Object类型是所有它的实例的基础，换句话说，Object类型具有的任何属性和方法也同样存在于更具体地对象中。
Object的每个实例都具有下列属性和方法：
·Constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object（）。
·hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中是否存在。
 其中，作为参数的属性名（propertyName）必须以字符串形式指定（o.hasOwnproperty("name"))。
·isPrototypeOf（object）：用于检查传入的对象是否是另一个对象的原型。
·propertyIsEnumerable（propertyName）：用于检查给定的属性是否能够使用for-in语句来枚举。作为参数的属性名（propertyName）必须以字符串形式指定。
·toLocalString（）：返回对象的字符串表示，该字符串与执行环境的地区对应。
·toString（）；返回对象的字符串表示。
·valueOf（）：返回对象的字符串、数值或布尔值表示。通常与toString（）方法的返回值相同。
第五章和第六章会详细介绍Object与其他对象的关系。
*BOM和DOM中的对象，属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此
 宿主对象可能会也可能不会继承Object。
