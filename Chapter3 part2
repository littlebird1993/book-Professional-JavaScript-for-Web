3.5操作符
 ECMA-262描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。
 ECMAScript操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值、甚至对象。
 不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf（）和（或）toString（）方法，以便取得可以操作的值。
 
 3.5.1一元操作符
 只能操作一个值的操作符叫做一元操作符。一元操作符是ECMAScript中最简单的操作符。
 1.递增和递减操作符
 递增和递减操作符
 递增和递减操作符直接借鉴自C，而且各有两个版本：前置型和后置型（++和--在变量前或变量后）。
 前置递增和递减操作符、后置递增和递减操作符对任何值都适用。规则：（暂不记录，在第38页）
 2.一元加和减操作符（+和-）
 同样可以对非数值应用。
 
 3.5.2位操作符
 位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。
 ECMAScript中所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。
 而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。（可能是将64位拆成前后两个32位来分别处理。）
 对于有符号的整数，32位中的前31位（数的第一位在最右边）用于表示整数的值。第32位用于表示数值的符号：0表示正数，1表示负数。
 这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。
 其中，正数以纯二进制格式存储，31位中的每一位都表示2的幂。第一位（叫做位0）表示2的零次方，第二位表示2的一次方，以此类推。
 没有用到的位以0填充，即忽略不计。
 例如，数值18的二进制表示是00000000000000000000000000010010，或更简洁的10010（这是5个有效位，决定了实际的值。）
负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列3个步骤：
1、求这个数值绝对值的二进制码。
2、求二进制反码，即将0替换为1，将1替换为0。
3、得到的二进制反码加1。
值得注意的是，在处理有符号整数时，是不能访问位31的。
ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。
var num = -18; 
alert(num.toString(2));    // "-10010"
默认情况下，ECMAScript中的所有整数都是有符号整数。不过，当然也存在无符号整数。
对于无符号整数来说，第32位不再表示符号，因为无符号整数只能是正数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示数值。
在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过 程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的 结果转换回64位数值。这样，表面上看起来就好像是在操作32位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也 导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。 

1. 按位非（NOT）
按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数 值的反码。按位非是ECMAScript操作符中少数几个与二进制计算有关 的操作符之一。下面看一个例子：
var num1 = 25;                  // 二进制00000000000000000000000000011001 
var num2 = ~num1;               // 二进制11111111111111111111111111100110 
alert(num2);                    // -26
这里，对25执行按位非操作，结果得到了-26。这也验证了按位非操作 的本质：操作数的负值减1。
因此，下面的代码也能得到相同的结果：
var num1 = 25; 
var num2 = -num1 - 1; 
alert(num2);            // "-26"
虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底 层执行操作，因此速度更快。

2. 按位与（AND） 
按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质 上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规 则，对相同位置上的两个数执行AND操作：
第一个数值的位 第二个数值的位  结果 
1             1             1 
1             0             0 
0             1             0 
0             0             0
简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一 位是0，结果都是0。 
下面看一个对25和3执行按位与操作的例子：
var result = 25 & 3; 
alert(result);     //1
可见，对25和3执行按位与操作的结果是1。为什么呢？请看其底层操作：
25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3  =  0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001

3. 按位或（OR） 
按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或 操作遵循下面这个真值表。
第一个数值的位 第二个数值的位  结果 
1             1             1 
1             0             1 
0             1             1 
0             0             0
由此可见，按位或操作在有一个位是1的情况下就返回1，而只有在两个 位都是0的情况下才返回0。 

4. 按位异或（XOR） 
按位异或操作符由一个插入符号（^）表示，也有两个操作数。以下是 按位异或的真值表。
第一个数值的位 第二个数值的位  结果 
1             1             0
1             0             1 
0             1             1 
0             0             0
按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有 一个1时才返回1，如果对应的两位都是1或都是0，则返回0。 

5. 左移
左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向 左移动指定的位数。例如，如果将数值2（二进制码为10）向左移动5 位，结果就是64（二进制码为1000000），代码如下所示：
var oldValue = 2;                       // 等于二进制的10
var newValue = oldValue << 5;           // 等于二进制的1000000，十进
注意，在向左移位后，原数值的右侧多出了5个空位。左移操作会以0来 填充这些空位，以便得到的结果是一个完整的32位二进制数。
注意，左移不会影响操作数的符号位。换句话说，如果将-2向左移动5 位，结果将是-64，而非64。 

6. 有符号的右移
有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向 右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2
同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现 在原数值的左侧、符号位的右侧。而此时ECMAScript会用符号位的值来填充所有空位(如果符号位是1就用1填充，是0就用0填充），以便得到一个完整的值。

7. 无符号右移
无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所 有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将64无符号右移5位，结果 仍然还是2。
但是对负数来说，情况就不一样了。
首先，无符号右移是以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数 的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。
其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。
而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：
var oldValue = -64;                     // 等于二进制的11111111111111111111111111000000 
var newValue = oldValue >>> 5;          // 等于十进制的134217726
这里，当对-64执行无符号右移5位的操作后，得到的结果是 134217726。之所以结果如此之大，是因为-64的二进制码为 11111111111111111111111111000000，而且无符号右移操作会把这个二进制码当成正数的二进制码，换算成十进制就是4294967232。如果把这个值右移5位，结果就变成了00000111111111111111111111111110，即 十进制的134217726。 




3.5.3　布尔操作符
在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么诸如if...else和循环之类的语句就不会有用武之地了。布尔操作符一共有3个：非（NOT）、与（AND）和或 （OR）。
1. 逻辑非（NOT)
逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript中的任 何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。 逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求 反。也就是说，逻辑非操作符遵循下列规则：
·如果操作数是一个对象，返回false； 
·如果操作数是一个空字符串，返回true； 
·如果操作数是一个非空字符串，返回false； 
·如果操作数是数值0，返回true； 
·如果操作数是任意非0数值（包括Infinity），返回false； 
·如果操作数是null，返回true； 
·如果操作数是NaN，返回true； 
·如果操作数是undefined，返回true。
逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使 用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。其 中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二 个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔 值。当然，最终结果与对这个值使用Boolean()函数相同。（就是连续两个！！就相当于Boolean（））
2. 逻辑与(AND)
逻辑与操作符由两个和号（&&）表示，有两个操作数。（真值表不打了，跟数学里的一样。）
逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：
·如果第一个操作数是对象，则返回第二个操作数；
·如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；
·如果两个操作数都是对象，则返回第二个操作数（这时，也就是第二个对象）； 
·如果有一个操作数是null，则返回null； 
·如果有一个操作数是NaN，则返回NaN； 
·如果有一个操作数是undefined，则返回undefined。
逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就 不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数 是false，则无论第二个操作数是什么值，结果都不再可能是true了。 来看下面的例子：
var found = true;
var result = (found && someUndefinedVariable);    // 这里会发生错误 
alert(result);    // 这一行不会执行
在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 someUndefinedVariable没有声明。由于变量found的值是true，所 以逻辑与操作符会继续对变量someUndefinedVariable求值。 但someUndefinedVariable尚未定义，因此就会导致错误。
这说明不能在逻辑与操作中使用未定义的值。将found的值设置为false，就不会发生错误了。
在使用逻辑与操作 符时要始终铭记它是一个短路操作符。
3. 逻辑或
逻辑或操作符由两个竖线符号（||）表示，有两个操作数。（真值表和数学里一样）
与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返 回布尔值；此时，它遵循下列规则：
·如果第一个操作数是对象，则返回第一个操作数；
·如果第一个操作数的求值结果为false，则返回第二个操作数；
·如果两个操作数都是对象，则返回第一个操作数；
·如果两个操作数都是null，则返回null； 
·如果两个操作数都是NaN，则返回NaN； 
·如果两个操作数都是undefined，则返回undefined。
与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果 第一个操作数的求值结果为true，就不会对第二个操作数求值了。
我们可以利用逻辑或的这一行为来避免为变量赋null或undefined值。 
例如：
var myObject = preferredObject || backupObject; （别看到有object，就当成是对象了，下面说了是变量。）
在这个例子中，变量myObject将被赋予等号后面两个值中的一个。变量preferredObject中包含优先赋给变量myObject的值，变量 backupObject负责在preferredObject中不包含有效值的情况下提供 后备值。如果preferredObject的值不是null，那么它的值将被赋给
myObject；如果是null，则将backupObject的值赋给myObject。 ECMAScript程序的赋值语句经常会使用这种模式，本书也将采用这种模式。




3.5.4　乘性操作符
ECMAScript定义了3个乘性操作符：乘法、除法和求模。这些操作符与 Java、C或者Perl中的相应操作符用途类似，只不过在操作数为非数值的 情况下会执行自动的类型转换。如果参与乘法计算的某个操作数不是数 值，后台会先使用Number()转型函数将其转换为数值。也就是说，空 字符串将被当作0，布尔值true将被当作1。
1. 乘法
乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。其语法 类似于C，如下面的例子所示：
var result = 34 * 56;
在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：
·如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负 数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果 就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回 Infinity或-Infinity； 
·如果有一个操作数是NaN，则结果是NaN；
·如果是Infinity与0相乘，则结果是NaN； 
·如果是Infinity与非0数值相乘，则结果是Infinity或Infinity，取决于有符号操作数的符号； 
·如果是Infinity与Infinity相乘，则结果是Infinity； 
·如果有一个操作数不是数值，则在后台调用Number()将其转换为 数值，然后再应用上面的规则。
2. 除法
除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算
与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：
·如果操作数都是数值，执行常规的除法计算，即两个正数或两个负 数相除的结果还是正数，而如果只有一个操作数有符号，那么结果 就是负数。如果商超过了ECMAScript数值的表示范围，则返回 Infinity或-Infinity；
·如果有一个操作数是NaN，则结果是NaN； 
·如果是Infinity被Infinity除，则结果是NaN； 
·如果是零被零除，则结果是NaN； 
·如果是非零的有限数被零除，则结果是Infinity或-Infinity， 取决于有符号操作数的符号；
·如果是Infinity被任何非零数值除，则结果是Infinity或Infinity，取决于有符号操作数的符号； 
·如果有一个操作数不是数值，则在后台调用Number()将其转换为 数值，然后再应用上面的规则。
3. 求模
求模（余数）操作符由一个百分号（%）表示，用法如下：
与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：
·如果操作数都是数值，执行常规的除法计算，返回除得的余数；
·如果被除数是无穷大值而除数是有限大的数值，则结果是NaN； 
·如果被除数是有限大的数值而除数是零，则结果是NaN； 
·如果是Infinity被Infinity除，则结果是NaN；
·如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
·如果被除数是零，则结果是零；
·如果有一个操作数不是数值，则在后台调用Number()将其转换为 数值，然后再应用上面的规则。




3.5.5　加性操作符
加法和减法这两个加性操作符应该说是编程语言中最简单的算术操作符 了。但是在ECMAScript中，这两个操作符却都有一系列的特殊行为。 与乘性操作符类似，加性操作符也会在后台转换不同的数据类型。然 而，对于加性操作符而言，相应的转换规则还稍微有点复杂。
