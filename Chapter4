第4章　变量、作用域和内存问题

按照ECMA-262的定义，JavaScript的变量与其他语言的变量有很大区 别。JavaScript变量松散类型的本质，决定了它只是在特定时间用于保存 特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据 类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。 尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的 特性，但JavaScript变量实际的复杂程度还远不止如此。



4.1　基本类型和引用类型的值
ECMAScript变量可能包含两种不同数据类型的值：
基本类型值和引用类型值。
基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。
在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
第3章讨论了5种基本数据类 型：Undefined、Null、Boolean、Number和String。这5种基本数据 类型是按值访问的，因为可以操作保存在变量中的实际的值。
引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允 许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在 操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

（网上摘录：js基本数据类型包括：undefined,null,number,boolean,string.基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值。 而引用类型就是：对象、数组、函数等，这些本质也都是对象。
实际上，两者最大的区别是就是在赋值的之后，到底是新开辟了一个内存（栈内存或者是堆内存），还是使用了原来的内存，只是复制了指针，这个是有根本区别的。)

4.1.1　动态的属性
定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变 量赋值。
但是，当这个值保存到变量中以后，对不同类型值可以执行的 操作则大相径庭。
对于引用类型的值，我们可以为其添加属性和方法， 也可以改变和删除其属性和方法。请看下面的例子：
var person = new Object(); 
person.name = "Nicholas"; 
alert(person.name);       //"Nicholas"
以上代码创建了一个对象并将其保存在了变量person中。
然后，我们为该对象添加了一个名为name的属性，并将字符串值"Nicholas"赋给了这个属性。
紧接着，又通过alert()函数访问了这个新属性。
如果对 象不被销毁或者这个属性不被删除，则这个属性将一直存在。
但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如:
var name = "Nicholas"; 
name.age = 27; 
alert(name.age);      //undefined



4.1.2　复制变量值
除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值 和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本 类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量 分配的位置上。来看一个例子：
var num1 = 5; 
var num2 = num1;
在此，num1中保存的值是5。当使用num1的值来初始化num2时，num2 中也保存了值5。但num2中的5与num1中的5是完全独立的，该值只是num1中5的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变 量对象中的值复制一份放到为新变量分配的空间中。
不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一 个变量，就会影响另一个变量，如下面的例子所示：
var obj1 = new Object(); 
var obj2 = obj1; 
obj1.name = "Nicholas"; 
alert(obj2.name);  //"Nicholas"
首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了 obj2中；换句话说，obj1和obj2都指向同一个对象。这样，当为obj1 添加name属性后，可以通过obj2来访问这个属性，因为这两个变量引 用的都是同一个对象。




4.1.3　传递参数
ECMAScript中所有函数的参数都是按值传递的。
也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。
基本类型值的传递如同基本类型变量的复制一样，而引用类型值 的传递，则如同引用类型变量的复制一样。
有不少开发人员在这一点上 可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能 按值传递。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象 中的一个元素）。 
在向参数传递引用类型的值时，会把这个值在内存中 的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面这个例子：
function addTen(num) {    
  num += 10;   
  return num; 
}
var count = 20;
var result = addTen(count); 
alert(count);    //20，没有变化 
alert(result);   //30
这里的函数addTen()有一个参数num，而参数实际上是函数的局部变量。
在调用这个函数时，变量count作为参数被传递给函数，这个变量 的值是20。
于是，数值20被复制给参数num以便在addTen()中使用。在 函数内部，参数num的值被加上了10，但这一变化不会影响函数外部的count变量。参数num与变量count互不相识，它们仅仅是具有相同的 值。

假如num是按引用传递的话，那么变量count的值也将变成30，从 而反映函数内部的修改。当然，使用数值等基本类型值来说明按值传递 参数比较简单，但如果使用对象，那问题就不怎么好理解了。再举一个例子：
function setName(obj) {    
  obj.name = "Nicholas"; 
}
var person = new Object(); 
setName(person); 
alert(person.name);    //"Nicholas"
以上代码中创建一个对象，并将其保存在了变量person中。然后，这 个对象被传递到setName()函数中之后就被复制给了obj。在这个函数 内部，obj和person引用的是同一个对象。
换句话说，即使这个对象是 按值传递的，obj也会按引用来访问同一个对象。于是，当在函数内部 为obj添加name属性后，函数外部的person也将有所反映；因 为person指向的对象在堆内存中只有一个，而且是全局对象。
有很多 开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反 映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我 们再看一看下面这个经过修改的例子：
function setName(obj) {    
  obj.name = "Nicholas";    
  obj = new Object();    
  obj.name = "Greg"; 
}
var person = new Object(); 
setName(person); 
alert(person.name);    //"Nicholas"
这个例子与前一个例子的唯一区别，就是在setName()函数中添加了两行代码：一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给setName()后， 其name属性被设置为"Nicholas"。然后，又将一个新对象赋给变量obj，同时将其name属性设置为"Greg"。如果person是按引用传递 的，那么person就会自动被修改为指向其name属性值为"Greg"的新对象。但是，当接下来再访问person.name时，显示的值仍然 是"Nicholas"。
这说明即使在函数内部修改了参数的值，但原始的引 用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的 就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
*可以把ECMAScript函数的参数想象成局部变量。 


4.1.4　检测类型
要检测一个变量是不是基本数据类型？第3章介绍的typeof操作符是最 佳的工具。说得更具体一点，typeof操作符是确定一个变量是字符 串、数值、布尔值，还是undefined的最佳工具。如果变量的值是一个 对象或null，则typeof操作符会像下面例子中所示的那样返 回"object"

虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用 类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值 是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof操作符，其语法如下所示：
result = variable instanceof constructor
如果变量是给定引用类型（根据它的原型链来识别；第6章将介绍原型链）的实例，那么instanceof操作符就会返回true。请看下面的例子：
alert(person instanceof Object);     // 变量person是Object吗？ 
alert(colors instanceof Array);      // 变量colors是Array吗？ 
alert(pattern instanceof RegExp);    // 变量pattern是RegExp吗？
根据规定，所有引用类型的值都是Object的实例。因此，在检测一个 引用类型值和Object构造函数时，instanceof操作符始终会返回 true。当然，如果使用instanceof操作符检测基本类型的值，则该操 作符始终会返回false，因为基本类型不是对象。

*使用typeof操作符检测函数时，该操作符会返回"function"。 在Safari 5及之前版本和Chrome 7及之前版本中使用typeof检测正则 表达式时，由于规范的原因，这个操作符也返回"function"。 ECMA-262规定任何在内部实现[[Call]]方法的对象都应该在应 用typeof操作符时返回"function"。由于上述浏览器中的正则表达 式也实现了这个方法，因此对正则表达式应用typeof会返 回"function"。在IE和Firefox中，对正则表达式应用typeof会返 回"object"。




4.2　执行环境及作用域
执行环境 定义了 变量或函数有权访问的其他数据，决定了它们各自的行为。
每个执行环境 有 一个与之关联的 变量对象（我们编写的代码无法访问，但解析器在处理数据时会在后台使用它）。
变量对象 保存着 执行环境定义的所有变量和函数。

全局执行环境：最外围的一个执行环境。宿主环境不同，执行环境的对象也不一样。
             在Web浏览器中，全局执行环境被认为时window对象。
             因此所有全局变量和函数都作为window对象的属性和方法创建的。
某执行环境代码执行完毕——该环境被销毁（例如关闭网页或浏览器时才销毁）——保存其中的所有变量和函数定义被销毁。
每个函数 都有 自己的执行环境。执行流 进入 一个函数时，函数的环境就会被推入一个环境栈中。
函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链。
         作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
         作用域链的前端，始终都是当前执行的代码所在环境的变量对象。（代码所在环境的变量对象）
         作用域的下一个变量对象，在包含（外部）环境，再下一个变量对象来自下一个包含（外部环境）。一直延续到全局执行环境。
         所以，全局执行环境的变量对象始终都是作用域链中的最后一个对象。
         
活动对象：如果这个环境是函数，则将其活动对象（activation object）作为变量对象。
         活动对象在最开始时只包含一个变量，即argumens对象（该对象在全局环境中不存在。）

标识符（identifier）：指用来标识某个实体的一个符号，在不同的应用环境下有不同的含义。
                     在计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。标识符通常                      由字母和数字以及其它字符构成。
         
标识符解析：沿着作用域链一级一级地搜索标识符的过程。
           搜索过程始 终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。（如果找不到标识符，通常会导致错误发生）。
           
请看下面的示例代码：
var color = "blue";
function changeColor(){    
    if (color === "blue"){        
    color = "red";    
  } else {        
    color = "blue";    
  } 
}
changeColor();
alert("Color is now " + color);
在这个简单的例子中，函数changeColor()的作用域链包含两个对象： 它自己的变量对象（其中定义着arguments对象）和全局环境的变量对 象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。

此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使 用，如下面这个例子所示：
var color = "blue";
function changeColor(){    
  var anotherColor = "red";
  function swapColors(){        
    var tempColor = anotherColor;        
    anotherColor = color;        
    color = tempColor;
    // 这里可以访问color、anotherColor和tempColor    }
  // 这里可以访问color和anotherColor，但不能访问tempColor    
  swapColors(); }
// 这里只能访问color 
changeColor();
以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境 和swapColors()的局部环境。全局环境中有一个变量color和一个函 数changeColor()。changeColor()的局部环境中有一个名 为anotherColor的变量和一个名为swapColors()的函数，但它也可以 访问全局环境中的变量color。swapColors()的局部环境中有一个变 量tempColor，该变量只能在这个环境中访问到。无论全局环境还 是changeColor()的局部环境都无权访问tempColor。然而， 在swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。
下图形象地展示了前面这个例子的作用域链：
window
  |
   ——color
  |
   ——changeColor（）
         |
          ——anotherColor（）
         |
          ——swapColors（）
              |
               ——tempColor
图4-3中的矩形表示特定的执行环境。其中，内部环境可以通过作用域 链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和 函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜 索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的swapColors()而 言，其作用域链中包含3个对象：swapColors()的变量对 象、changeColor()的变量对象和全局变量对象。swapColors()的局 部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不 到则再搜索上一级作用域链。changeColor()的作用域链中只包含两个 对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 swapColors()的 环境。
 * 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。




 

